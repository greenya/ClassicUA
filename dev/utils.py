import math
import re
from pathlib import Path
from xml.etree import ElementTree

known_expansions = ('classic', 'sod', 'tbc', 'wrath', 'cata', 'mists')
known_expansions_inclusion = {
    # this should match expansion TOC files
    'classic'   : ('classic'),
    'sod'       : ('classic', 'sod'),
    'tbc'       : ('classic', 'tbc'),
    'wrath'     : ('classic', 'tbc', 'wrath'),
    'cata'      : ('classic', 'tbc', 'wrath', 'cata'),
    'mists'     : ('classic', 'tbc', 'wrath', 'cata', 'mists'),
}
known_sides = ('alliance', 'horde', 'both')

is_str_and_has_only_ascii_chars =\
    lambda s: isinstance(s, str) and s == s.encode(encoding='utf-8').decode('ascii', errors='ignore')

def get_quest_filename(quest_id, quest_title):
    valid_chars = frozenset('-.() abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    return ''.join(c for c in quest_title if c in valid_chars) + '_' + str(quest_id)

def get_clean_text(text):
    '''
    Cleans up given text.

    Examples:
    ```
    * 'ab c' -> (no changes)
    * '\\nabc' -> (no changes)
    * 'abc\\n\\n\\nabc' -> (no changes)
    * ' ' -> ''
    * ' abc ' -> ' abc'
    * 'abc\\n' -> 'abc'
    * 'abc \\n abc' -> 'abc\\n abc'
    * 'ab\u2019c' -> "ab'c"
    * 'a \u201Dbc\u201D' -> 'a "bc"'
    * 'ab \u2013 c' -> 'ab \u2014 c'
    ```
    '''

    lines = text.split('\n')

    last_non_empty_line_idx = -1
    for i in range(len(lines)):
        lines[i] = lines[i]\
            .rstrip()\
            .replace('\u2019', "'")\
            .replace('\u201D', '"')\
            .replace('\u2013', '\u2014')

        if lines[i]:
            last_non_empty_line_idx = i

    return '\n'.join(lines[:last_non_empty_line_idx + 1]) if last_non_empty_line_idx >= 0 else ''

def get_strings_map_from_xml_file(filename) -> map | list:
    result, issues = {}, []

    for s in ElementTree.parse(filename).getroot().findall('./string'):
        if not s.text: continue

        name = s.attrib["name"]
        text = s.text

        if not name:
            issues.append(f'[!] {filename} has string without name. Each string must have unique name within the file. String text: "{text}". The string is skipped.')
            continue

        if name in result:
            issues.append(f'[!] {filename} has string with duplicated name ("{name}"). This new string is skipped.')

        result[name] = get_clean_text(s.text)

    return result, issues

def build_strings_list(en_strings_map: map, uk_strings_map: list, hash_func: callable = None, code_func: callable = None) -> list | list:
    result, issues = [], []
    all_en_hashes, all_en_codes = [], []

    for name in uk_strings_map:
        if name not in en_strings_map:
            issues.append(f'[!] String name "{name}" is found in UK strings, but not found in EN strings. This string is skipped.')
            continue

        uk = uk_strings_map[name]
        en = en_strings_map[name]

        if uk == en:
            continue

        en_hash = hash_func(en) if hash_func else None
        en_code = None
        if code_func:
            en_code, en_code_error = code_func(en)
            issues += [en_code_error] if en_code_error is not None else []

        if en_hash in all_en_hashes:
            issues.append(f'[!] Text hash {en_hash} collision -- new data skipped: "{en}", "{uk}"')
            continue

        if en_code in all_en_codes:
            issues.append(f'[!] Text code "{en_code}" collision -- new data skipped: "{en}", "{uk}"')
            continue

        result.append({
            'en'        : en,
            'uk'        : uk,
            'en_hash'   : en_hash,
            'en_code'   : en_code,
        })

    return result, issues

def write_xml_quest_file(filename, title, objective, description, progress, completion):
    with open(filename, mode='w', encoding='utf-8', newline='\n') as f:
        f.write('<?xml version="1.0" encoding="utf-8"?>\n')
        f.write('<resources>\n')
        f.write(f'<string name="TITLE"><![CDATA[{title}]]></string>\n')
        if objective:
            f.write(f'<string name="OBJECTIVE"><![CDATA[{objective}]]></string>\n')
        if description:
            f.write(f'<string name="DESCRIPTION"><![CDATA[{description}]]></string>\n')
        if progress:
            f.write(f'<string name="PROGRESS"><![CDATA[{progress}]]></string>\n')
        if completion:
            f.write(f'<string name="COMPLETION"><![CDATA[{completion}]]></string>\n')
        f.write('</resources>\n')

def write_lua_autogenerated_file_comment(f):
    f.write('-- -------------------------------- --\n')
    f.write('-- AUTOGENERATED FILE. DO NOT EDIT. --\n')
    f.write('-- -------------------------------- --\n\n')

def write_lua_assign_or_copy_table_code(f, var):
    f.write(f'if addonTable.{var} then\n')
    f.write(f'    for k, v in pairs({var}) do addonTable.{var}[k] = v end\n')
    f.write('else\n')
    f.write(f'    addonTable.{var} = {var}\n')
    f.write('end\n')

def write_lua_assign_or_merge_table_one_level_code(f, var):
    f.write(f'if addonTable.{var} then\n')
    f.write(f'    for k, v in pairs({var}) do\n')
    f.write(f'        if type(addonTable.{var}[k]) == "table" and type(v) == "table" then\n')
    f.write(f'            for vk, vv in pairs(v) do\n')
    f.write(f'                addonTable.{var}[k][vk] = vv\n')
    f.write(f'            end\n')
    f.write(f'        else\n')
    f.write(f'            addonTable.{var}[k] = v\n')
    f.write(f'        end\n')
    f.write(f'    end\n')
    f.write('else\n')
    f.write(f'    addonTable.{var} = {var}\n')
    f.write('end\n')

def write_lua_quest_file(path, filename, var, quests):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('local ' + var + ' = { -- [id] = { title, description, objective, progress, completion }\n')

        for q in quests:
            id, en, title, objective, description, progress, completion = q.values()

            title = f'[===[{title}]===]'
            objective = f'[===[{objective}]===]' if objective else 'nil'
            description = f'[===[{description}]===]' if description else 'nil'
            progress = f'[===[{progress}]===]' if progress else 'nil'
            completion = f'[===[{completion}]===]' if completion else 'nil'

            f.write(f'[{id}] = ' + '{ en="' + en.replace('"', r'\"') + '",\n')
            f.write(f'{title},\n')
            f.write(f'{description},\n')
            f.write(f'{objective},\n')
            f.write(f'{progress},\n')
            f.write(f'{completion},\n')
            f.write('},\n')

        f.write('}\n\n')
        write_lua_assign_or_copy_table_code(f, var)

def write_lua_book_file(path, filename, books):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('local book = { -- [id] = { page1, page2 (optional), page3 (optional), ... }\n')

        for id in books:
            pages, hint = books[id]

            f.write(f'[{id}] = ' + '{' + f' -- {hint}\n')
            for page in pages:
                f.write(f'[===[{page}]===],\n')
            f.write('},\n')

        f.write('}\n\n')
        write_lua_assign_or_copy_table_code(f, 'book')

def write_lua_npc_file(path, filename, npcs):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('local npc = { -- [id] = { title, description (optional) }\n')

        for id in npcs:
            title, desc, en, hint = npcs[id]
            f.write('[' + str(id) + '] = { "' + title.replace('"', r'\"') + '"')

            if desc:
                f.write(', "' + desc.replace('"', r'\"') + '"')

            if en:
                f.write(', en="' + en.replace('"', r'\"') + '"')

            f.write(' },' + f' -- {hint}\n')

        f.write('}\n\n')
        write_lua_assign_or_copy_table_code(f, 'npc')

def write_lua_zone_file(path, filename, zones):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('addonTable.zone = { -- [key] = text\n')

        for key in zones:
            value = zones[key]
            f.write('["' + key.replace('"', r'\"') + '"] = ' + '"' + value.replace('"', r'\"') + '",\n')

        f.write('}\n')

def write_lua_misc_file(path, filename, misc):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('addonTable.misc = { -- [key] = text\n')

        for key in misc:
            value = misc[key]
            f.write('["' + key.replace('"', r'\"') + '"] = ' + '"' + value.replace('"', r'\"') + '",\n')

        f.write('}\n')

def write_lua_glossary_file(path, filename, glossary):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('addonTable.glossary = { -- [key] = text\n')

        for key in glossary:
            value = glossary[key]
            f.write('["' + key.replace('"', r'\"') + '"] = ' + '"' + value.replace('"', r'\"') + '",\n')

        f.write('}\n')

def write_lua_gossip_file(path, filename, gossip):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('local gossip = { -- [npc_id] = { [hash]=translation, ..., [!code]={...} (optional) }, ... }\n')

        for npc_id in gossip:
            npc_name = gossip[npc_id]['name']
            npc_strings = gossip[npc_id]['strings']

            if npc_name:
                f.write(f'[{npc_id}] = ' + '{' + f' -- {npc_name}\n')
            else:
                f.write(f'["{npc_id}"] = ' + '{\n')

            has_en_codes = False

            for string in npc_strings:
                en = string['en']
                uk = string['uk']
                en_hash = string['en_hash']
                en_code = string['en_code']

                if en_code:
                    has_en_codes = True

                for s in en.split('\n'):
                    f.write(f'--{' ' + s if s else ''}\n')

                f.write(f'[{en_hash}] = [===[{uk}]===],\n')

            if has_en_codes:
                f.write('["!code"] = {\n')

                for string in npc_strings:
                    en_hash = string['en_hash']
                    en_code = string['en_code']
                    if en_code:
                        f.write(f'["{en_code}"] = {en_hash},\n')

                f.write('},\n')

            f.write('},\n')

        f.write('}\n\n')
        write_lua_assign_or_merge_table_one_level_code(f, 'gossip')

def write_lua_chat_file(path, filename, chats):
    Path(path).mkdir(parents=True, exist_ok=True)
    with open(f'{path}/{filename}.lua', mode='w', encoding='utf-8', newline='\n') as f:
        write_lua_autogenerated_file_comment(f)
        f.write('local _, addonTable = ...\n\n')
        f.write('local chat = { -- [npc_name_en] = { [1] = npc_name_uk (optional), [hash]=translation, ..., [!code]={ [code]=hash, ...} (optional) }\n')

        for npc_name in chats:
            npc_name_uk = chats[npc_name]['uk']
            npc_strings = chats[npc_name]['strings']

            if npc_name_uk:
                f.write('["' + npc_name.replace('"', r'\"') + '"] = { "' + npc_name_uk.replace('"', r'\"') + '",\n')
            else:
                f.write('["' + npc_name.replace('"', r'\"') + '"] = {\n')

            has_en_codes = False

            for string in npc_strings:
                text_en = string['en']
                text_uk = string['uk']
                en_hash = string['en_hash']
                en_code = string['en_code']

                if en_code:
                    has_en_codes = True

                for s in text_en.split('\n'):
                    f.write(f'--{' ' + s if s else ''}\n')

                f.write(f'[{en_hash}] = [===[{text_uk}]===],\n')

            if has_en_codes:
                f.write('["!code"] = {\n')

                for string in npc_strings:
                    en_hash = string['en_hash']
                    en_code = string['en_code']
                    if en_code:
                        f.write(f'["{en_code}"] = {en_hash},\n')

                f.write('},\n')

            f.write('},\n')

        f.write('}\n\n')
        write_lua_assign_or_merge_table_one_level_code(f, 'chat')

# [!] Any changes made to string_hash() func must be kept in sync with Lua impl
def string_hash(text: str) -> int:
    if not text:
        return 0

    counter = 1
    text_len = len(text)
    for i in range(0, text_len, 3):
        counter = math.fmod(counter * 8161, 4294967279) +\
            (ord(text[i]) * 16776193) +\
            ((ord(text[i+1]) if text_len > i+1 else (text_len - (i+1) + 256)) * 8372226) +\
            ((ord(text[i+2]) if text_len > i+2 else (text_len - (i+1) + 256)) * 3932164)

    return int(math.fmod(counter, 4294967291))

# [!] Any changes made to get_text_hash() func must be kept in sync with Lua impl
def get_text_hash(text: str) -> int:
    return string_hash(text.strip().lower()) if isinstance(text, str) else 0

known_gossip_dynamic_seq_with_multiple_words_for_get_text_code = (
    ("night elf", "nightelf"),
    ("blood elf", "bloodelf"),
    ("death knight", "deathknight"),
    ("demon hunter", "demonhunter"),
    ("void elf", "voidelf"),
    ("lightforged draenei", "lightforgeddraenei"),
    ("dark iron dwarf", "darkirondwarf"),
    ("kul tiran", "kultiran"),
    ("highmountain tauren", "highmountaintauren"),
    ("mag'har orc", "magharorc"),
    ("zandalari troll", "zandalaritroll"),
)
MAX_CODE_LENGTH = 40

# [!] Any changes made to get_text_code() func must be kept in sync with Lua impl in main.lua
def get_text_code(text) -> (str, str):
    text = text.lower()
    for p in known_gossip_dynamic_seq_with_multiple_words_for_get_text_code:
        text = text.replace(p[0], p[1])

    words = re.findall(r"""([\w<][\w\-'/]*[\w>])""", text)  # matches words with at least 2 word-characters and allows punctuation characters inside (boss-lady, ma'am, etc)
    result = list()
    for word in words:
        if len(word) > 0:
            if word.startswith('<'):
                #  It should be <class>, <race>, <name>, <target> or gender-specific text (<his/her>)
                # FIXME: if gender template contains space - it will not work (like <he's a king/she's a queen>)
                if not word.endswith('>'):
                    return None, f'[!] Template code missmatch during code creation for text "{text}"'
                template_type = word[1:-1]
                if template_type in ('class', 'race'):
                    result.append('..')
                elif template_type in ('name', 'target'):
                    result.append('.-')
                elif '/' in template_type:
                    male_word, female_word = template_type.split('/')
                    if male_word[0] == female_word[0]:
                        result.append(male_word[0])
                    else:
                        result.append('.')
                    if male_word[-1] == female_word[-1]:
                        result.append(male_word[-1])
                    else:
                        result.append('.')
            else:
                result.append(word[0])
                result.append(word[-1])
        if len(result) >= MAX_CODE_LENGTH:
            break

    return ''.join(result), None
